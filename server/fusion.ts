// AUTO-GENERATED BY KIRO
// REVIEW REQUIRED: Face detection and masking policy
import express, { type Request, type Response } from "express";
import multer from "multer";
import path from "path";
import { v2 as cloudinary } from "cloudinary";
import crypto from "crypto";
import { Readable } from "stream";
import { storage } from "./storage.js";

// Ensure Cloudinary is configured (it should be configured in routes.ts, but ensure it here too)
if (!cloudinary.config().cloud_name) {
  // Cloudinary not configured, try to configure it
  if (process.env.CLOUDINARY_URL) {
    cloudinary.config({
      secure: true,
    });
  } else {
    cloudinary.config({
      cloud_name: process.env.CLOUDINARY_CLOUD_NAME || "dzxawjlvs",
      api_key: process.env.CLOUDINARY_API_KEY || "893663778162643",
      api_secret: process.env.CLOUDINARY_API_SECRET || "_ThzqgrXbg3IHRlqhSJll92P7_w",
      secure: true,
    });
  }
}

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { 
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 2 // Allow up to 2 files
  },
  fileFilter: (req, file, cb) => {
    // More lenient file type checking
    const allowedTypes = /jpeg|jpg|png|webp/i;
    const extname = file.originalname ? allowedTypes.test(path.extname(file.originalname).toLowerCase()) : false;
    const mimetype = file.mimetype ? allowedTypes.test(file.mimetype.toLowerCase()) : false;
    
    // Accept if either extension or mimetype matches
    if (extname || mimetype) {
      return cb(null, true);
    }
    
    // Log for debugging
    console.warn("File rejected:", {
      originalname: file.originalname,
      mimetype: file.mimetype,
      extname: path.extname(file.originalname || "").toLowerCase()
    });
    
    cb(new Error(`Only image files (PNG, JPG, JPEG, WEBP) are allowed. Got: ${file.mimetype || "unknown"}`));
  },
});

// Validate image upload
export async function validateUpload(file: Express.Multer.File): Promise<{
  valid: boolean;
  error?: string;
}> {
  // Check if file exists
  if (!file) {
    return { valid: false, error: "File is missing" };
  }

  // Check file type - be more lenient with MIME types
  const allowedMimeTypes = ["image/png", "image/jpeg", "image/jpg", "image/webp", "image/x-png"];
  const allowedExtensions = [".png", ".jpg", ".jpeg", ".webp"];
  
  const hasValidMimeType = allowedMimeTypes.includes(file.mimetype?.toLowerCase() || "");
  const hasValidExtension = allowedExtensions.some(ext => 
    file.originalname?.toLowerCase().endsWith(ext)
  );
  
  if (!hasValidMimeType && !hasValidExtension) {
    return { 
      valid: false, 
      error: `Invalid file type: ${file.mimetype || "unknown"}. Only PNG, JPG, JPEG, WEBP allowed.` 
    };
  }

  // Check file size (10MB max)
  if (file.size > 10 * 1024 * 1024) {
    return { valid: false, error: `File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 10MB limit.` };
  }

  // Check minimum file size (at least 1KB)
  if (file.size < 1024) {
    return { valid: false, error: "File is too small. Minimum size is 1KB." };
  }

  // TODO: Check dimensions (min 512x512, max 2048x2048)
  // This would require image processing library like sharp

  return { valid: true };
}

// Upload images to Cloudinary
export async function uploadImages(files: Express.Multer.File[]): Promise<string[]> {
  const uploadPromises = files.map((file) => {
    return new Promise<string>((resolve, reject) => {
      try {
        const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
        const publicId = `fusion/uploads/${uniqueSuffix}`;

        // Convert buffer to stream for Cloudinary
        const bufferStream = new Readable();
        bufferStream.push(file.buffer);
        bufferStream.push(null); // End the stream

        const uploadStream = cloudinary.uploader.upload_stream(
          {
            public_id: publicId,
            folder: "fusion/uploads",
            resource_type: "image",
            transformation: [{ quality: "auto:best" }],
          },
          (error, result) => {
            if (error) {
              console.error("Cloudinary upload error:", error);
              reject(error);
            } else if (result) {
              resolve(result.secure_url);
            } else {
              reject(new Error("Cloudinary upload failed: No result returned"));
            }
          }
        );

        // Pipe the buffer stream to Cloudinary
        bufferStream.pipe(uploadStream);
      } catch (error) {
        console.error("Error preparing upload:", error);
        reject(error);
      }
    });
  });

  return Promise.all(uploadPromises);
}

// Create fusion job
export async function createFusionJob(
  imageA: string,
  imageB: string,
  mode: "pattern" | "color" | "texture",
  strength: number,
  designerId?: string
): Promise<string> {
  const jobId = crypto.randomUUID();
  
  // Store job in database
  const newJob = await storage.createFusionJob({
    jobId,
    imageA,
    imageB,
    mode,
    strength,
    status: "pending",
    progress: 0,
    designerId,
  });

  // Start processing in background (non-blocking)
  import("./fusionPipeline.js").then(({ processFusionJob }) => {
    processFusionJob(jobId).catch((error) => {
      console.error("Background fusion processing error:", error);
    });
  });

  return jobId;
}

// Setup fusion routes
export function setupFusionRoutes(app: express.Express) {
  // Upload images
  app.post(
    "/api/fusion/upload",
    (req: Request, res: Response, next: express.NextFunction) => {
      // Handle multer errors
      upload.array("images", 2)(req, res, (err: any) => {
        if (err) {
          console.error("Multer error:", err);
          console.error("Multer error code:", err.code);
          console.error("Multer error message:", err.message);
          
          if (err.code === "LIMIT_FILE_SIZE") {
            return res.status(400).json({ error: "File too large. Maximum size is 10MB per file." });
          }
          if (err.code === "LIMIT_FILE_COUNT") {
            return res.status(400).json({ error: "Too many files. Maximum is 2 files." });
          }
          if (err.code === "LIMIT_UNEXPECTED_FILE") {
            return res.status(400).json({ error: "Unexpected file field. Use 'images' field name." });
          }
          if (err.message) {
            return res.status(400).json({ error: err.message });
          }
          return res.status(400).json({ error: "File upload error", code: err.code });
        }
        next();
      });
    },
    async (req: Request, res: Response) => {
      try {
        console.log("Upload request received");
        console.log("Content-Type:", req.headers["content-type"]);
        console.log("Files:", req.files ? (Array.isArray(req.files) ? `${req.files.length} files` : typeof req.files) : "none");
        
        // Check if files were parsed
        if (!req.files) {
          return res.status(400).json({ 
            error: "No files in request. Make sure to use 'images' as the field name and Content-Type: multipart/form-data" 
          });
        }
        
        if (!Array.isArray(req.files)) {
          return res.status(400).json({ 
            error: "Invalid file format. Expected array of files." 
          });
        }
        
        if (req.files.length === 0) {
          return res.status(400).json({ error: "No files uploaded. Please select at least one image." });
        }

        const files = req.files as Express.Multer.File[];
        console.log(`Processing ${files.length} files`);
        
        // Validate each file
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          console.log(`Validating file ${i + 1}:`, {
            name: file.originalname,
            type: file.mimetype,
            size: file.size,
            hasBuffer: !!file.buffer,
            bufferLength: file.buffer?.length || 0
          });
          
          const validation = await validateUpload(file);
          if (!validation.valid) {
            return res.status(400).json({ 
              error: `File ${i + 1} (${file.originalname}): ${validation.error}` 
            });
          }
        }

        // Upload to Cloudinary
        console.log(`Uploading ${files.length} files to Cloudinary...`);
        const urls = await uploadImages(files);
        console.log("Upload successful, URLs:", urls);

        res.json({
          success: true,
          images: urls.map((url) => ({ url })),
        });
      } catch (error: any) {
        console.error("Upload error:", error);
        console.error("Error stack:", error.stack);
        res.status(500).json({ 
          error: error.message || "Upload failed",
          details: process.env.NODE_ENV === "development" ? error.stack : undefined
        });
      }
    }
  );

  // Create fusion job
  app.post("/api/fusion/create", async (req: Request, res: Response) => {
    try {
      const { imageA, imageB, mode, strength } = req.body;

      if (!imageA || !imageB) {
        return res.status(400).json({ error: "Both imageA and imageB required" });
      }

      if (!["pattern", "color", "texture"].includes(mode)) {
        return res.status(400).json({ error: "Invalid mode" });
      }

      if (typeof strength !== "number" || strength < 0.5 || strength > 0.9) {
        return res.status(400).json({ error: "Strength must be between 0.5 and 0.9" });
      }

      const jobId = await createFusionJob(imageA, imageB, mode, strength);

      res.json({
        success: true,
        jobId,
      });
    } catch (error: any) {
      console.error("Create fusion job error:", error);
      res.status(500).json({ error: error.message || "Failed to create fusion job" });
    }
  });

  // Get job status
  app.get("/api/fusion/status/:jobId", async (req: Request, res: Response) => {
    try {
      const { jobId } = req.params;
      
      const job = await storage.getFusionJob(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      console.log(`Status check for job ${jobId}:`, {
        status: job.status,
        progress: job.progress,
        hasResultUrl: !!job.resultUrl,
        resultUrl: job.resultUrl,
        candidatesCount: job.candidates?.length || 0,
      });
      
      res.json({
        jobId: job.jobId,
        status: job.status,
        progress: job.progress,
        resultUrl: job.resultUrl,
        candidates: job.candidates || [],
        explainability: job.explainability,
        error: job.error,
      });
    } catch (error: any) {
      console.error("Get status error:", error);
      res.status(500).json({ error: error.message || "Failed to get status" });
    }
  });

  // Get job results
  app.get("/api/fusion/results/:jobId", async (req: Request, res: Response) => {
    try {
      const { jobId } = req.params;
      
      const job = await storage.getFusionJob(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      res.json({
        jobId: job.jobId,
        status: job.status,
        progress: job.progress,
        resultUrl: job.resultUrl,
        candidates: job.candidates || [],
        explainability: job.explainability,
        error: job.error,
      });
    } catch (error: any) {
      console.error("Get results error:", error);
      res.status(500).json({ error: error.message || "Failed to get results" });
    }
  });

  // Delete image
  app.delete("/api/fusion/image/:imageId", async (req: Request, res: Response) => {
    try {
      const { imageId } = req.params;
      
      // TODO: Delete from Cloudinary and database
      
      res.json({ success: true });
    } catch (error: any) {
      console.error("Delete image error:", error);
      res.status(500).json({ error: error.message || "Failed to delete image" });
    }
  });

  // Generate lookbook
  app.post("/api/fusion/lookbook", async (req: Request, res: Response) => {
    try {
      const { jobId, baseImageUrl, count = 6 } = req.body;
      
      // TODO: Generate variations using fusion pipeline
      
      // Mock response
      const variations = Array.from({ length: count }, (_, i) => 
        `/api/placeholder/512/512?text=Variation+${i + 1}`
      );
      
      res.json({ variations });
    } catch (error: any) {
      console.error("Lookbook generation error:", error);
      res.status(500).json({ error: error.message || "Failed to generate lookbook" });
    }
  });

  // Generate social share card
  app.post("/api/fusion/share-card", async (req: Request, res: Response) => {
    try {
      const { jobId, resultUrl, dimensions } = req.body;
      
      // TODO: Generate 1080x1080 card with overlays
      
      // Mock response
      res.json({
        shareCardUrl: `/api/placeholder/${dimensions.width}/${dimensions.height}?text=Share+Card`,
      });
    } catch (error: any) {
      console.error("Share card generation error:", error);
      res.status(500).json({ error: error.message || "Failed to generate share card" });
    }
  });
}

