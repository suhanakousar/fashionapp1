// AUTO-GENERATED BY KIRO
// REVIEW REQUIRED: Face detection and masking policy
import express, { type Request, type Response } from "express";
import multer from "multer";
import path from "path";
import { v2 as cloudinary } from "cloudinary";
import crypto from "crypto";
import { storage } from "./storage.js";

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|webp/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    if (mimetype && extname) {
      return cb(null, true);
    }
    cb(new Error("Only image files (PNG, JPG, JPEG, WEBP) are allowed"));
  },
});

// Validate image upload
export async function validateUpload(file: Express.Multer.File): Promise<{
  valid: boolean;
  error?: string;
}> {
  // Check file type
  const allowedTypes = ["image/png", "image/jpeg", "image/jpg", "image/webp"];
  if (!allowedTypes.includes(file.mimetype)) {
    return { valid: false, error: "Invalid file type. Only PNG, JPG, JPEG, WEBP allowed." };
  }

  // Check file size (10MB max)
  if (file.size > 10 * 1024 * 1024) {
    return { valid: false, error: "File size exceeds 10MB limit." };
  }

  // TODO: Check dimensions (min 512x512, max 2048x2048)
  // This would require image processing library like sharp

  return { valid: true };
}

// Upload images to Cloudinary
export async function uploadImages(files: Express.Multer.File[]): Promise<string[]> {
  const uploadPromises = files.map((file) => {
    return new Promise<string>((resolve, reject) => {
      const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
      const publicId = `fusion/uploads/${uniqueSuffix}`;

      cloudinary.uploader.upload_stream(
        {
          public_id: publicId,
          folder: "fusion/uploads",
          resource_type: "image",
          transformation: [{ quality: "auto:best" }],
        },
        (error, result) => {
          if (error) reject(error);
          else resolve(result!.secure_url);
        }
      ).end(file.buffer);
    });
  });

  return Promise.all(uploadPromises);
}

// Create fusion job
export async function createFusionJob(
  imageA: string,
  imageB: string,
  mode: "pattern" | "color" | "texture",
  strength: number,
  designerId?: string
): Promise<string> {
  const jobId = crypto.randomUUID();
  
  // Store job in database
  const newJob = await storage.createFusionJob({
    jobId,
    imageA,
    imageB,
    mode,
    strength,
    status: "pending",
    progress: 0,
    designerId,
  });

  // Start processing in background (non-blocking)
  import("./fusionPipeline.js").then(({ processFusionJob }) => {
    processFusionJob(jobId).catch((error) => {
      console.error("Background fusion processing error:", error);
    });
  });

  return jobId;
}

// Setup fusion routes
export function setupFusionRoutes(app: express.Express) {
  // Upload images
  app.post(
    "/api/fusion/upload",
    upload.array("images", 2),
    async (req: Request, res: Response) => {
      try {
        if (!req.files || !Array.isArray(req.files) || req.files.length === 0) {
          return res.status(400).json({ error: "No files uploaded" });
        }

        const files = req.files as Express.Multer.File[];
        
        // Validate each file
        for (const file of files) {
          const validation = await validateUpload(file);
          if (!validation.valid) {
            return res.status(400).json({ error: validation.error });
          }
        }

        // REVIEW REQUIRED: Face detection
        // const facesDetected = await detectFaces(files);
        // if (facesDetected && !req.body.consent) {
        //   return res.status(400).json({ 
        //     error: "Faces detected. Please provide consent for face masking." 
        //   });
        // }

        // Upload to Cloudinary
        const urls = await uploadImages(files);

        res.json({
          success: true,
          images: urls.map((url) => ({ url })),
        });
      } catch (error: any) {
        console.error("Upload error:", error);
        res.status(500).json({ error: error.message || "Upload failed" });
      }
    }
  );

  // Create fusion job
  app.post("/api/fusion/create", async (req: Request, res: Response) => {
    try {
      const { imageA, imageB, mode, strength } = req.body;

      if (!imageA || !imageB) {
        return res.status(400).json({ error: "Both imageA and imageB required" });
      }

      if (!["pattern", "color", "texture"].includes(mode)) {
        return res.status(400).json({ error: "Invalid mode" });
      }

      if (typeof strength !== "number" || strength < 0.5 || strength > 0.9) {
        return res.status(400).json({ error: "Strength must be between 0.5 and 0.9" });
      }

      const jobId = await createFusionJob(imageA, imageB, mode, strength);

      res.json({
        success: true,
        jobId,
      });
    } catch (error: any) {
      console.error("Create fusion job error:", error);
      res.status(500).json({ error: error.message || "Failed to create fusion job" });
    }
  });

  // Get job status
  app.get("/api/fusion/status/:jobId", async (req: Request, res: Response) => {
    try {
      const { jobId } = req.params;
      
      const job = await storage.getFusionJob(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      res.json({
        jobId: job.jobId,
        status: job.status,
        progress: job.progress,
        resultUrl: job.resultUrl,
        candidates: job.candidates,
        error: job.error,
      });
    } catch (error: any) {
      console.error("Get status error:", error);
      res.status(500).json({ error: error.message || "Failed to get status" });
    }
  });

  // Get job results
  app.get("/api/fusion/results/:jobId", async (req: Request, res: Response) => {
    try {
      const { jobId } = req.params;
      
      const job = await storage.getFusionJob(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      
      res.json({
        jobId: job.jobId,
        status: job.status,
        progress: job.progress,
        resultUrl: job.resultUrl,
        candidates: job.candidates || [],
        explainability: job.explainability,
        error: job.error,
      });
    } catch (error: any) {
      console.error("Get results error:", error);
      res.status(500).json({ error: error.message || "Failed to get results" });
    }
  });

  // Delete image
  app.delete("/api/fusion/image/:imageId", async (req: Request, res: Response) => {
    try {
      const { imageId } = req.params;
      
      // TODO: Delete from Cloudinary and database
      
      res.json({ success: true });
    } catch (error: any) {
      console.error("Delete image error:", error);
      res.status(500).json({ error: error.message || "Failed to delete image" });
    }
  });

  // Generate lookbook
  app.post("/api/fusion/lookbook", async (req: Request, res: Response) => {
    try {
      const { jobId, baseImageUrl, count = 6 } = req.body;
      
      // TODO: Generate variations using fusion pipeline
      
      // Mock response
      const variations = Array.from({ length: count }, (_, i) => 
        `/api/placeholder/512/512?text=Variation+${i + 1}`
      );
      
      res.json({ variations });
    } catch (error: any) {
      console.error("Lookbook generation error:", error);
      res.status(500).json({ error: error.message || "Failed to generate lookbook" });
    }
  });

  // Generate social share card
  app.post("/api/fusion/share-card", async (req: Request, res: Response) => {
    try {
      const { jobId, resultUrl, dimensions } = req.body;
      
      // TODO: Generate 1080x1080 card with overlays
      
      // Mock response
      res.json({
        shareCardUrl: `/api/placeholder/${dimensions.width}/${dimensions.height}?text=Share+Card`,
      });
    } catch (error: any) {
      console.error("Share card generation error:", error);
      res.status(500).json({ error: error.message || "Failed to generate share card" });
    }
  });
}

