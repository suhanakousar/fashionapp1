// AUTO-GENERATED BY KIRO
// Replicate API wrapper (alternative to Bytez/HF)
// REVIEW REQUIRED: API key management

const REPLICATE_API_URL = "https://api.replicate.com/v1";
const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;

export interface ReplicatePrediction {
  id: string;
  status: "starting" | "processing" | "succeeded" | "failed" | "canceled";
  output?: string | string[];
  error?: string;
}

/**
 * Create a Replicate prediction
 */
export async function createReplicatePrediction(
  modelId: string,
  input: Record<string, unknown>
): Promise<ReplicatePrediction> {
  if (!REPLICATE_API_TOKEN) {
    throw new Error("REPLICATE_API_TOKEN not configured");
  }

  async function getFetch() {
    try {
      // Try to use node-fetch if available (optional dependency)
      // @ts-ignore - node-fetch is optional
      const nodeFetch = await import("node-fetch").catch(() => null);
      if (nodeFetch) {
        return nodeFetch.default as any;
      }
    } catch {
      // Ignore
    }
    // Use global fetch (available in Node 18+)
    return globalThis.fetch;
  }

  try {
    const fetchFn = await getFetch();
    const response = await fetchFn(`${REPLICATE_API_URL}/predictions`, {
      method: "POST",
      headers: {
        "Authorization": `Token ${REPLICATE_API_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        version: modelId, // Replicate uses version IDs
        input,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Replicate API error: ${response.status} ${errorText}`);
    }

    return await response.json() as ReplicatePrediction;
  } catch (error: any) {
    console.error("Replicate API error:", error);
    throw error;
  }
}

/**
 * Get prediction status (poll until complete)
 */
export async function getReplicatePrediction(
  predictionId: string
): Promise<ReplicatePrediction> {
  if (!REPLICATE_API_TOKEN) {
    throw new Error("REPLICATE_API_TOKEN not configured");
  }

  async function getFetch() {
    try {
      // Try to use node-fetch if available (optional dependency)
      // @ts-ignore - node-fetch is optional
      const nodeFetch = await import("node-fetch").catch(() => null);
      if (nodeFetch) {
        return nodeFetch.default as any;
      }
    } catch {
      // Ignore
    }
    // Use global fetch (available in Node 18+)
    return globalThis.fetch;
  }

  try {
    const fetchFn = await getFetch();
    const response = await fetchFn(`${REPLICATE_API_URL}/predictions/${predictionId}`, {
      headers: {
        "Authorization": `Token ${REPLICATE_API_TOKEN}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Replicate API error: ${response.status}`);
    }

    return await response.json() as ReplicatePrediction;
  } catch (error: any) {
    console.error("Replicate API error:", error);
    throw error;
  }
}

/**
 * Poll prediction until complete (with timeout)
 */
export async function waitForReplicatePrediction(
  predictionId: string,
  timeoutMs: number = 300000 // 5 minutes
): Promise<ReplicatePrediction> {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeoutMs) {
    const prediction = await getReplicatePrediction(predictionId);
    
    if (prediction.status === "succeeded") {
      return prediction;
    }
    
    if (prediction.status === "failed" || prediction.status === "canceled") {
      throw new Error(`Prediction ${prediction.status}: ${prediction.error || "Unknown error"}`);
    }
    
    // Wait before polling again
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
  
  throw new Error("Prediction timeout");
}

/**
 * ControlNet + SD via Replicate
 */
export async function generateImageReplicate(
  initImage: string,
  prompt: string,
  negativePrompt: string,
  controlnetImage: string,
  options: {
    strength: number;
    guidanceScale?: number;
    steps?: number;
  }
): Promise<string> { // Returns image URL
  try {
    const prediction = await createReplicatePrediction(
      "lllyasviel/control_v11p_sd15_canny", // Example model version
      {
        image: initImage,
        prompt,
        negative_prompt: negativePrompt,
        control_image: controlnetImage,
        strength: options.strength,
        guidance_scale: options.guidanceScale || 7.5,
        num_inference_steps: options.steps || 25,
      }
    );

    const completed = await waitForReplicatePrediction(prediction.id);
    
    if (typeof completed.output === "string") {
      return completed.output;
    } else if (Array.isArray(completed.output) && completed.output.length > 0) {
      return completed.output[0];
    }
    
    throw new Error("Invalid output from Replicate");
  } catch (error) {
    console.error("Replicate image generation error:", error);
    throw error;
  }
}

