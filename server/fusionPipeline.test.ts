// AUTO-GENERATED BY KIRO
// Jest unit tests for fusion pipeline
import { describe, it, expect, jest, beforeEach } from "@jest/globals";
import { processFusionJob, detectFaces, extractFeatures, generateExplainability } from "./fusionPipeline.js";
import { storage } from "./storage.js";

// Mock dependencies
jest.mock("./storage.js");
jest.mock("cloudinary", () => ({
  v2: {
    api: {
      resource: jest.fn(),
    },
    url: jest.fn(),
    uploader: {
      upload_stream: jest.fn(),
    },
  },
}));

describe("Fusion Pipeline", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("detectFaces", () => {
    it("should detect faces in image", async () => {
      // Mock Cloudinary response
      const mockCloudinary = require("cloudinary").v2;
      mockCloudinary.api.resource.mockResolvedValue({
        faces: [[100, 100, 50, 50]],
      });

      const result = await detectFaces("https://example.com/image.jpg");
      expect(result.hasFaces).toBe(true);
      expect(result.faceCount).toBe(1);
    });

    it("should return no faces if detection fails", async () => {
      const mockCloudinary = require("cloudinary").v2;
      mockCloudinary.api.resource.mockRejectedValue(new Error("API error"));

      const result = await detectFaces("https://example.com/image.jpg");
      expect(result.hasFaces).toBe(false);
      expect(result.faceCount).toBe(0);
    });
  });

  describe("extractFeatures", () => {
    it("should extract palette and patterns", async () => {
      const features = await extractFeatures("https://example.com/image.jpg");
      expect(features).toHaveProperty("palette");
      expect(features).toHaveProperty("dominantPattern");
      expect(features).toHaveProperty("garmentType");
      expect(Array.isArray(features.palette)).toBe(true);
    });
  });

  describe("generateExplainability", () => {
    it("should generate explainability data for pattern mode", async () => {
      const result = await generateExplainability(
        "https://example.com/imageA.jpg",
        "https://example.com/imageB.jpg",
        "https://example.com/result.jpg",
        "pattern"
      );

      expect(result).toHaveProperty("designerNote");
      expect(result).toHaveProperty("contributionRegions");
      expect(result.contributionRegions.length).toBeGreaterThan(0);
      expect(result.contributionRegions[0]).toHaveProperty("region");
      expect(result.contributionRegions[0]).toHaveProperty("contribution");
      expect(result.contributionRegions[0]).toHaveProperty("pattern");
    });
  });

  describe("processFusionJob", () => {
    it("should process fusion job successfully", async () => {
      const mockJob = {
        jobId: "test-job-id",
        imageA: "https://example.com/imageA.jpg",
        imageB: "https://example.com/imageB.jpg",
        mode: "pattern" as const,
        strength: 0.7,
        status: "pending" as const,
        progress: 0,
      };

      (storage.getFusionJob as jest.Mock).mockResolvedValue(mockJob);
      (storage.updateFusionJob as jest.Mock).mockResolvedValue(mockJob);

      // Mock face detection (no faces)
      const { detectFaces } = require("./fusionPipeline.js");
      jest.spyOn(require("./fusionPipeline.js"), "detectFaces").mockResolvedValue({
        hasFaces: false,
        faceCount: 0,
      });

      await processFusionJob("test-job-id");

      expect(storage.getFusionJob).toHaveBeenCalledWith("test-job-id");
      expect(storage.updateFusionJob).toHaveBeenCalled();
    });

    it("should fail if faces detected without consent", async () => {
      const mockJob = {
        jobId: "test-job-id",
        imageA: "https://example.com/imageA.jpg",
        imageB: "https://example.com/imageB.jpg",
        mode: "pattern" as const,
        strength: 0.7,
        status: "pending" as const,
        progress: 0,
      };

      (storage.getFusionJob as jest.Mock).mockResolvedValue(mockJob);
      (storage.updateFusionJob as jest.Mock).mockResolvedValue(mockJob);

      // Mock face detection (faces found)
      jest.spyOn(require("./fusionPipeline.js"), "detectFaces").mockResolvedValue({
        hasFaces: true,
        faceCount: 1,
        faces: [{ x: 100, y: 100, width: 50, height: 50 }],
      });

      // Set environment to not auto-mask
      const originalEnv = process.env.AUTO_MASK_FACES;
      delete process.env.AUTO_MASK_FACES;

      await processFusionJob("test-job-id");

      expect(storage.updateFusionJob).toHaveBeenCalledWith(
        "test-job-id",
        expect.objectContaining({
          status: "failed",
          error: expect.stringContaining("Faces detected"),
        })
      );

      // Restore env
      if (originalEnv) process.env.AUTO_MASK_FACES = originalEnv;
    });
  });
});

