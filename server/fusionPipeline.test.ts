// AUTO-GENERATED BY KIRO
// Jest tests for fusion pipeline with mocked model responses

import { describe, it, expect, jest, beforeEach } from "@jest/globals";
import { processFusionJob } from "./fusionPipeline.js";
import { storage } from "./storage.js";
import * as faceProtect from "./faceProtect.js";
import * as hfModels from "./models/huggingface.js";

// Mock dependencies
jest.mock("./storage.js");
jest.mock("./faceProtect.js");
jest.mock("./models/huggingface.js");
jest.mock("./models/bytez.js");
jest.mock("./models/replicate.js");
jest.mock("cloudinary", () => ({
  v2: {
    uploader: {
      upload_stream: jest.fn((options, callback) => {
        callback(null, { secure_url: "https://cloudinary.com/mock.jpg" });
        return { end: jest.fn() };
      }),
    },
    url: jest.fn((publicId, options) => `https://cloudinary.com/${publicId}.jpg`),
    api: {
      resource: jest.fn(() => Promise.resolve({ faces: [] })),
    },
  },
}));

describe("Fusion Pipeline", () => {
  const mockJob = {
    jobId: "test-job-123",
    category: "lehenga" as const,
    fabricTop: "https://cloudinary.com/fabric-top.jpg",
    fabricBottom: "https://cloudinary.com/fabric-bottom.jpg",
    fabricTrims: "https://cloudinary.com/fabric-trims.jpg",
    mode: "hybrid" as const,
    strength: 0.5,
    status: "pending" as const,
    progress: 0,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should process fusion job successfully", async () => {
    // Mock storage
    (storage.getFusionJob as jest.Mock).mockResolvedValue(mockJob);
    (storage.updateFusionJob as jest.Mock).mockResolvedValue(mockJob);

    // Mock face detection (no faces)
    (faceProtect.checkFaceProtection as jest.Mock).mockResolvedValue({
      requiresProtection: false,
      protected: false,
      faceDetections: [],
    });

    // Mock feature extraction
    (hfModels.extractCLIPFeatures as jest.Mock).mockResolvedValue([0.1, 0.2, 0.3]);

    // Mock image generation
    const mockBlob = new Blob(["mock"], { type: "image/jpeg" });
    (hfModels.generateImageHF as jest.Mock).mockResolvedValue(mockBlob);
    (hfModels.upscaleImageHF as jest.Mock).mockResolvedValue(mockBlob);

    await processFusionJob("test-job-123");

    expect(storage.getFusionJob).toHaveBeenCalledWith("test-job-123");
    expect(storage.updateFusionJob).toHaveBeenCalledWith(
      "test-job-123",
      expect.objectContaining({ status: "completed", progress: 100 })
    );
  });

  it("should abort if faces detected without consent", async () => {
    (storage.getFusionJob as jest.Mock).mockResolvedValue(mockJob);
    (storage.updateFusionJob as jest.Mock).mockResolvedValue(mockJob);

    (faceProtect.checkFaceProtection as jest.Mock).mockResolvedValue({
      requiresProtection: true,
      protected: false,
      faceDetections: [{ hasFaces: true, faceCount: 1 }],
      error: "Faces detected. Please provide consent.",
    });

    await processFusionJob("test-job-123");

    expect(storage.updateFusionJob).toHaveBeenCalledWith(
      "test-job-123",
      expect.objectContaining({ status: "failed" })
    );
  });

  it("should handle missing fabric images gracefully", async () => {
    const jobWithoutFabrics = {
      ...mockJob,
      fabricTop: undefined,
      fabricBottom: undefined,
      fabricTrims: undefined,
    };

    (storage.getFusionJob as jest.Mock).mockResolvedValue(jobWithoutFabrics);
    (storage.updateFusionJob as jest.Mock).mockResolvedValue(jobWithoutFabrics);

    (faceProtect.checkFaceProtection as jest.Mock).mockResolvedValue({
      requiresProtection: false,
      protected: false,
      faceDetections: [],
    });

    // Should still process with legacy imageA/imageB if available
    await expect(processFusionJob("test-job-123")).rejects.toThrow();
  });

  it("should generate 3 candidates (one per mode)", async () => {
    (storage.getFusionJob as jest.Mock).mockResolvedValue(mockJob);
    (storage.updateFusionJob as jest.Mock).mockResolvedValue(mockJob);

    (faceProtect.checkFaceProtection as jest.Mock).mockResolvedValue({
      requiresProtection: false,
      protected: false,
      faceDetections: [],
    });

    const mockBlob = new Blob(["mock"], { type: "image/jpeg" });
    (hfModels.generateImageHF as jest.Mock).mockResolvedValue(mockBlob);
    (hfModels.upscaleImageHF as jest.Mock).mockResolvedValue(mockBlob);
    (hfModels.extractCLIPFeatures as jest.Mock).mockResolvedValue([]);

    await processFusionJob("test-job-123");

    // Should generate 3 candidates
    expect(hfModels.generateImageHF).toHaveBeenCalledTimes(3);
    
    // Check that updateFusionJob was called with candidates
    const updateCalls = (storage.updateFusionJob as jest.Mock).mock.calls;
    const candidatesCall = updateCalls.find((call) => call[1].candidates);
    expect(candidatesCall).toBeDefined();
    expect(candidatesCall[1].candidates.length).toBeGreaterThan(0);
  });

  it("should handle API failures with fallback", async () => {
    (storage.getFusionJob as jest.Mock).mockResolvedValue(mockJob);
    (storage.updateFusionJob as jest.Mock).mockResolvedValue(mockJob);

    (faceProtect.checkFaceProtection as jest.Mock).mockResolvedValue({
      requiresProtection: false,
      protected: false,
      faceDetections: [],
    });

    // Mock API failure
    (hfModels.generateImageHF as jest.Mock).mockRejectedValue(
      new Error("API error")
    );

    // Should still complete with mock fallback
    await processFusionJob("test-job-123");

    expect(storage.updateFusionJob).toHaveBeenCalledWith(
      "test-job-123",
      expect.objectContaining({ status: "completed" })
    );
  });
});
