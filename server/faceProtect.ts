// AUTO-GENERATED BY KIRO
// REVIEW REQUIRED: Face detection and masking policy
// Face protection module for fusion pipeline

import { v2 as cloudinary } from "cloudinary";
import { detectFacesHF } from "./models/huggingface.js";
import { detectFacesBytez } from "./models/bytez.js";

export interface FaceDetectionResult {
  hasFaces: boolean;
  faceCount: number;
  faces: Array<{
    x: number;
    y: number;
    width: number;
    height: number;
  }>;
  faceProtected: boolean;
}

export interface FaceMask {
  maskUrl: string; // Cloudinary URL of mask
  regions: Array<{ x: number; y: number; width: number; height: number }>;
}

/**
 * Detect faces in image using multiple providers (fallback chain)
 */
export async function detectFaces(
  imageUrl: string,
  options?: { requireConsent?: boolean }
): Promise<FaceDetectionResult> {
  // Try HuggingFace first, then Bytez, then Cloudinary
  let result: FaceDetectionResult = {
    hasFaces: false,
    faceCount: 0,
    faces: [],
    faceProtected: false,
  };

  // Try HuggingFace
  try {
    if (process.env.HUGGINGFACE_API_KEY) {
      const hfResult = await detectFacesHF(imageUrl);
      result = {
        hasFaces: hfResult.hasFaces,
        faceCount: hfResult.faceCount,
        faces: hfResult.faces || [],
        faceProtected: hfResult.hasFaces && (options?.requireConsent === false || process.env.AUTO_MASK_FACES === "true"),
      };
      if (result.hasFaces) return result;
    }
  } catch (error) {
    console.warn("HF face detection failed, trying fallback:", error);
  }

  // Try Bytez
  try {
    if (process.env.BYTEZ_API_KEY) {
      const bytezResult = await detectFacesBytez(imageUrl);
      result = {
        hasFaces: bytezResult.hasFaces,
        faceCount: bytezResult.faceCount,
        faces: bytezResult.faces || [],
        faceProtected: bytezResult.hasFaces && (options?.requireConsent === false || process.env.AUTO_MASK_FACES === "true"),
      };
      if (result.hasFaces) return result;
    }
  } catch (error) {
    console.warn("Bytez face detection failed, trying Cloudinary:", error);
  }

  // Fallback to Cloudinary
  try {
    const publicId = extractPublicId(imageUrl);
    if (publicId) {
      const cloudinaryResult = await cloudinary.api.resource(publicId, {
        resource_type: "image",
        faces: true,
      });

      const faces = (cloudinaryResult.faces as any[]) || [];
      result = {
        hasFaces: faces.length > 0,
        faceCount: faces.length,
        faces: faces.map((f: any) => ({
          x: f[0] || f.x,
          y: f[1] || f.y,
          width: f[2] || f.width,
          height: f[3] || f.height,
        })),
        faceProtected: faces.length > 0 && (options?.requireConsent === false || process.env.AUTO_MASK_FACES === "true"),
      };
    }
  } catch (error) {
    console.warn("Cloudinary face detection failed:", error);
  }

  return result;
}

/**
 * Create face mask image (black mask with white regions for faces)
 * REVIEW REQUIRED: This creates a mask that protects faces - policy decision needed
 */
export async function createFaceMask(
  imageUrl: string,
  faces: Array<{ x: number; y: number; width: number; height: number }>
): Promise<FaceMask> {
  if (faces.length === 0) {
    return { maskUrl: "", regions: [] };
  }

  try {
    const publicId = extractPublicId(imageUrl);
    if (!publicId) {
      throw new Error("Cannot extract public ID from image URL");
    }

    // Create mask using Cloudinary overlays
    // This is a simplified approach - in production, you'd generate a proper mask image
    const maskUrl = cloudinary.url(publicId, {
      transformation: [
        { width: 1024, height: 1024, crop: "fill" },
        // Add face regions as overlays (this is a placeholder - actual implementation would create a proper mask)
        ...faces.map((face, idx) => ({
          overlay: `text:face_${idx}`,
          width: face.width,
          height: face.height,
          x: face.x,
          y: face.y,
          gravity: "north_west",
          opacity: 100,
        })),
      ],
    });

    return {
      maskUrl,
      regions: faces,
    };
  } catch (error) {
    console.error("Face mask creation error:", error);
    throw error;
  }
}

/**
 * Check if face protection is required and handle consent
 * REVIEW REQUIRED: This is where consent logic should be implemented
 */
export async function checkFaceProtection(
  imageUrls: string[],
  userConsent?: boolean
): Promise<{
  requiresProtection: boolean;
  protected: boolean;
  faceDetections: FaceDetectionResult[];
  error?: string;
}> {
  const faceDetections: FaceDetectionResult[] = [];
  let requiresProtection = false;

  for (const url of imageUrls) {
    const detection = await detectFaces(url, { requireConsent: !userConsent });
    faceDetections.push(detection);
    if (detection.hasFaces) {
      requiresProtection = true;
    }
  }

  // REVIEW REQUIRED: Policy decision
  // Option 1: Require explicit consent if faces detected
  if (requiresProtection && userConsent === undefined) {
    return {
      requiresProtection: true,
      protected: false,
      faceDetections,
      error: "Faces detected. Please provide consent for face masking or use images without faces.",
    };
  }

  // Option 2: Auto-mask if consent given or AUTO_MASK_FACES enabled
  const isProtected = requiresProtection && (userConsent === true || process.env.AUTO_MASK_FACES === "true");

  return {
    requiresProtection,
    protected: isProtected,
    faceDetections,
  };
}

/**
 * Detect faces and create mask (for fusion pipeline)
 * REVIEW REQUIRED: Face protection logic must be verified for legal/privacy compliance.
 */
export async function detectFacesAndMask(
  imageUrl: string
): Promise<{
  faces: Array<{ x: number; y: number; width: number; height: number }>;
  faceMaskBase64?: string;
  faceDetected: boolean;
}> {
  const detection = await detectFaces(imageUrl);
  
  if (!detection.hasFaces || detection.faces.length === 0) {
    return {
      faces: [],
      faceDetected: false,
    };
  }
  
  // Create face mask as base64 PNG
  // In production, you'd use sharp or canvas to create a proper mask image
  try {
    // Fetch image to get dimensions
    const response = await fetch(imageUrl);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    
    // Use sharp to create mask
    const sharp = (await import("sharp")).default;
    const metadata = await sharp(buffer).metadata();
    const width = metadata.width || 1024;
    const height = metadata.height || 1536;
    
    // Create black mask with white regions for faces
    const maskImage = await sharp({
      create: {
        width,
        height,
        channels: 1, // Grayscale
        background: { r: 0, g: 0, b: 0 }, // Black background
      },
    })
      .composite(
        detection.faces.map((face) => ({
          input: {
            create: {
              width: face.width,
              height: face.height,
              channels: 1,
              background: { r: 255, g: 255, b: 255 }, // White for face region
            },
          },
          left: face.x,
          top: face.y,
          blend: "over",
        }))
      )
      .png()
      .toBuffer();
    
    const faceMaskBase64 = `data:image/png;base64,${maskImage.toString("base64")}`;
    
    return {
      faces: detection.faces,
      faceMaskBase64,
      faceDetected: true,
    };
  } catch (error) {
    console.error("Face mask creation error:", error);
    // Return faces without mask if mask creation fails
    return {
      faces: detection.faces,
      faceDetected: true,
    };
  }
}

/**
 * Extract Cloudinary public ID from URL
 */
function extractPublicId(url: string): string | null {
  try {
    if (url.includes("cloudinary.com")) {
      const match = url.match(/\/upload\/(?:v\d+\/)?(.+)$/);
      if (match && match[1]) {
        return match[1].replace(/\.(jpg|jpeg|png|webp)$/i, "");
      }
    }
    return null;
  } catch (e) {
    return null;
  }
}

