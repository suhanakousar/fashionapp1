// AUTO-GENERATED BY KIRO
// REVIEW REQUIRED: Face detection and masking policy
// Face protection module for fusion pipeline

import { v2 as cloudinary } from "cloudinary";
import { detectFacesHF } from "./models/huggingface.js";
import { detectFacesBytez } from "./models/bytez.js";

export interface FaceDetectionResult {
  hasFaces: boolean;
  faceCount: number;
  faces: Array<{
    x: number;
    y: number;
    width: number;
    height: number;
  }>;
  faceProtected: boolean;
}

export interface FaceMask {
  maskUrl: string; // Cloudinary URL of mask
  regions: Array<{ x: number; y: number; width: number; height: number }>;
}

/**
 * Detect faces in image using multiple providers (fallback chain)
 */
export async function detectFaces(
  imageUrl: string,
  options?: { requireConsent?: boolean }
): Promise<FaceDetectionResult> {
  // Try HuggingFace first, then Bytez, then Cloudinary
  let result: FaceDetectionResult = {
    hasFaces: false,
    faceCount: 0,
    faces: [],
    faceProtected: false,
  };

  // Try HuggingFace
  try {
    if (process.env.HUGGINGFACE_API_KEY) {
      const hfResult = await detectFacesHF(imageUrl);
      result = {
        hasFaces: hfResult.hasFaces,
        faceCount: hfResult.faceCount,
        faces: hfResult.faces || [],
        faceProtected: hfResult.hasFaces && (options?.requireConsent === false || process.env.AUTO_MASK_FACES === "true"),
      };
      if (result.hasFaces) return result;
    }
  } catch (error) {
    console.warn("HF face detection failed, trying fallback:", error);
  }

  // Try Bytez
  try {
    if (process.env.BYTEZ_API_KEY) {
      const bytezResult = await detectFacesBytez(imageUrl);
      result = {
        hasFaces: bytezResult.hasFaces,
        faceCount: bytezResult.faceCount,
        faces: bytezResult.faces || [],
        faceProtected: bytezResult.hasFaces && (options?.requireConsent === false || process.env.AUTO_MASK_FACES === "true"),
      };
      if (result.hasFaces) return result;
    }
  } catch (error) {
    console.warn("Bytez face detection failed, trying Cloudinary:", error);
  }

  // Fallback to Cloudinary
  try {
    const publicId = extractPublicId(imageUrl);
    if (publicId) {
      const cloudinaryResult = await cloudinary.api.resource(publicId, {
        resource_type: "image",
        faces: true,
      });

      const faces = (cloudinaryResult.faces as any[]) || [];
      result = {
        hasFaces: faces.length > 0,
        faceCount: faces.length,
        faces: faces.map((f: any) => ({
          x: f[0] || f.x,
          y: f[1] || f.y,
          width: f[2] || f.width,
          height: f[3] || f.height,
        })),
        faceProtected: faces.length > 0 && (options?.requireConsent === false || process.env.AUTO_MASK_FACES === "true"),
      };
    }
  } catch (error) {
    console.warn("Cloudinary face detection failed:", error);
  }

  return result;
}

/**
 * Create face mask image (black mask with white regions for faces)
 * REVIEW REQUIRED: This creates a mask that protects faces - policy decision needed
 */
export async function createFaceMask(
  imageUrl: string,
  faces: Array<{ x: number; y: number; width: number; height: number }>
): Promise<FaceMask> {
  if (faces.length === 0) {
    return { maskUrl: "", regions: [] };
  }

  try {
    const publicId = extractPublicId(imageUrl);
    if (!publicId) {
      throw new Error("Cannot extract public ID from image URL");
    }

    // Create mask using Cloudinary overlays
    // This is a simplified approach - in production, you'd generate a proper mask image
    const maskUrl = cloudinary.url(publicId, {
      transformation: [
        { width: 1024, height: 1024, crop: "fill" },
        // Add face regions as overlays (this is a placeholder - actual implementation would create a proper mask)
        ...faces.map((face, idx) => ({
          overlay: `text:face_${idx}`,
          width: face.width,
          height: face.height,
          x: face.x,
          y: face.y,
          gravity: "north_west",
          opacity: 100,
        })),
      ],
    });

    return {
      maskUrl,
      regions: faces,
    };
  } catch (error) {
    console.error("Face mask creation error:", error);
    throw error;
  }
}

/**
 * Check if face protection is required and handle consent
 * REVIEW REQUIRED: This is where consent logic should be implemented
 */
export async function checkFaceProtection(
  imageUrls: string[],
  userConsent?: boolean
): Promise<{
  requiresProtection: boolean;
  protected: boolean;
  faceDetections: FaceDetectionResult[];
  error?: string;
}> {
  const faceDetections: FaceDetectionResult[] = [];
  let requiresProtection = false;

  for (const url of imageUrls) {
    const detection = await detectFaces(url, { requireConsent: !userConsent });
    faceDetections.push(detection);
    if (detection.hasFaces) {
      requiresProtection = true;
    }
  }

  // REVIEW REQUIRED: Policy decision
  // Option 1: Require explicit consent if faces detected
  if (requiresProtection && userConsent === undefined) {
    return {
      requiresProtection: true,
      protected: false,
      faceDetections,
      error: "Faces detected. Please provide consent for face masking or use images without faces.",
    };
  }

  // Option 2: Auto-mask if consent given or AUTO_MASK_FACES enabled
  const isProtected = requiresProtection && (userConsent === true || process.env.AUTO_MASK_FACES === "true");

  return {
    requiresProtection,
    protected: isProtected,
    faceDetections,
  };
}

/**
 * Extract Cloudinary public ID from URL
 */
function extractPublicId(url: string): string | null {
  try {
    if (url.includes("cloudinary.com")) {
      const match = url.match(/\/upload\/(?:v\d+\/)?(.+)$/);
      if (match && match[1]) {
        return match[1].replace(/\.(jpg|jpeg|png|webp)$/i, "");
      }
    }
    return null;
  } catch (e) {
    return null;
  }
}

